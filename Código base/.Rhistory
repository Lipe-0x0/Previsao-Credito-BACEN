predicao = predict(modeloNB, amostra_teste, type = "raw")
# Criando coluna de probabilidade e de inadimplencia
predicao = as.data.frame(predicao)
predicao$prob = ifelse(predicao$nao>predicao$sim, predicao$nao, predicao$sim)
predicao$inadimplente = ifelse(predicao$nao>predicao$sim, "nao", "sim")
predicao$inadimplente = as.factor(predicao$inadimplente)
# Proporção de erros e acertos
table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente)
prop.table(table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente))*100
# Matriz de Confusão
confuso = confusionMatrix(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente, positive = "nao")
confuso$overall[1]# acuracia 0.77
confuso$byClass[5]# precisao 0.79
confuso$byClass[1]# reconhecimento 0.85
1-((80+7178)/(16189+1274+80+7178))
# Vamos usar a função do pacote gmodels para comparar as classificações
# do modelo aos dados de treinamento com a classificação real
CrossTable(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c("Inadimplência real", "Inadimplência predita"))
prop.table(table(amostra$numero_de_operacoes == "15"))
prop.table(table(bacen$numero_de_operacoes == "15"))
prop.table(table(bacen$numero_de_operacoes == "<=15"))
prop.table(table(bacen$numero_de_operacoes == "<= 15"))
rm(list = ls())
bacen = read.csv("C:/Users/lipe2/Downloads/OneDrive_2025-08-21/1º Hackaton Decat/Dados BACEN 2025.csv")
prop.table(table(bacen$uf))*100 # Trabalhando com todas os estados do nordeste
unique(bacen$uf)
# Utilizando AAEs
# 9 estratos
N = 1252617
Wh = c(97827/1252617,
247209/1252617,
164299/1252617,
134916/1252617,
122114/1252617,
182164/1252617,
96499/1252617,
121168/1252617,
86421/1252617)
Nh = c(97827,
247209,
164299,
134916,
122114,
182164,
96499,
121168,
86421)
q = qnorm(1-0.05/2)
PropH = as.data.frame(bacen|>
group_by(uf)|>
summarise("soma_nao" = sum(carteira_inadimplida_arrastada == "nao"),
"quantidade_uf" = table(uf),
"proporcao_nao" = soma_nao/quantidade_uf))$proporcao_nao
num = sum((Wh^2)*
(Nh/(Nh-1))*
((PropH*(1-PropH))/Wh))
den = ((0.01/q)^2)+
sum((Wh^2)*
((PropH*(1-PropH))/(Nh-1)))
n = num/den
# amostra 1
set.seed(1234)
ind = sample(1:N,n)
amostra = bacen[ind,]
amostra$data_base = NULL
amostra$uf = NULL
# Alterando tipo das variaveis
amostra$Mes = factor(amostra$Mes, levels = c("jan","fev","mar","abr","mai","jun"),
ordered = T)
amostra$carteira_inadimplida_arrastada = factor(amostra$carteira_inadimplida_arrastada,
levels = c("nao","sim"),
ordered = T)
amostra = amostra|>
mutate(across(tcb:indexador, as.factor)) # Fator
# Editando variavel "numero_de_operacoes"
amostra$numero_de_operacoes = ifelse(amostra$numero_de_operacoes == "<= 15", "15", amostra$numero_de_operacoes)
amostra$numero_de_operacoes = as.numeric(amostra$numero_de_operacoes)
set.seed(123)
ind = sample(1:n,n*0.1)
amostra_treino = amostra[-ind,]
amostra_teste = amostra[ind,]
# /-------------Naive Bayes (e1071)-------------\
# Aplicando o modelo de Naive Bayes (Probabilidade Condicional)
modeloNB = e1071::naiveBayes(carteira_inadimplida_arrastada ~ .,data = amostra_treino)
predicao = predict(modeloNB, amostra_teste, type = "raw")
# Criando coluna de probabilidade e de inadimplencia
predicao = as.data.frame(predicao)
predicao$prob = ifelse(predicao$nao>predicao$sim, predicao$nao, predicao$sim)
predicao$inadimplente = ifelse(predicao$nao>predicao$sim, "nao", "sim")
predicao$inadimplente = as.factor(predicao$inadimplente)
# Proporção de erros e acertos
table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente)
prop.table(table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente))*100
# Matriz de Confusão
confuso = confusionMatrix(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente, positive = "nao")
confuso$overall[1]# acuracia 0.73
confuso$byClass[5]# precisao 0.99
confuso$byClass[1]# reconhecimento 0.71
1-((80+7178)/(16189+1274+80+7178))
# Vamos usar a função do pacote gmodels para comparar as classificações
# do modelo aos dados de treinamento com a classificação real
CrossTable(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c("Inadimplência real", "Inadimplência predita"))
set.seed(12345)
ind = sample(1:N,n)
amostra = bacen[ind,]
amostra$data_base = NULL
amostra$uf = NULL
# Alterando tipo das variaveis
amostra$Mes = factor(amostra$Mes, levels = c("jan","fev","mar","abr","mai","jun"),
ordered = T)
amostra$carteira_inadimplida_arrastada = factor(amostra$carteira_inadimplida_arrastada,
levels = c("nao","sim"),
ordered = T)
amostra = amostra|>
mutate(across(tcb:indexador, as.factor)) # Fator
# Editando variavel "numero_de_operacoes"
# Como "<= 15" é aproximadamente 74% da variável então compensa mais categorizar em intervalos
amostra$numero_de_operacoes = ifelse(amostra$numero_de_operacoes == "<= 15", "15", amostra$numero_de_operacoes)
amostra$numero_de_operacoes = as.numeric(amostra$numero_de_operacoes)
set.seed(123)
ind = sample(1:n,n*0.1)
amostra_treino = amostra[-ind,]
amostra_teste = amostra[ind,]
# /-------------Naive Bayes (e1071)-------------\
# Aplicando o modelo de Naive Bayes (Probabilidade Condicional)
modeloNB = e1071::naiveBayes(carteira_inadimplida_arrastada ~ .,data = amostra_treino)
predicao = predict(modeloNB, amostra_teste, type = "raw")
# Criando coluna de probabilidade e de inadimplencia
predicao = as.data.frame(predicao)
predicao$prob = ifelse(predicao$nao>predicao$sim, predicao$nao, predicao$sim)
predicao$inadimplente = ifelse(predicao$nao>predicao$sim, "nao", "sim")
predicao$inadimplente = as.factor(predicao$inadimplente)
# Proporção de erros e acertos
table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente)
prop.table(table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente))*100
# Matriz de Confusão
confuso = confusionMatrix(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente, positive = "nao")
confuso$overall[1]# acuracia 0.73
confuso$byClass[5]# precisao 0.99
confuso$byClass[1]# reconhecimento 0.71
1-((80+7178)/(16189+1274+80+7178))
# Vamos usar a função do pacote gmodels para comparar as classificações
# do modelo aos dados de treinamento com a classificação real
CrossTable(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c("Inadimplência real", "Inadimplência predita"))
set.seed(12346)
ind = sample(1:N,n)
amostra = bacen[ind,]
amostra$data_base = NULL
amostra$uf = NULL
# Alterando tipo das variaveis
amostra$Mes = factor(amostra$Mes, levels = c("jan","fev","mar","abr","mai","jun"),
ordered = T)
amostra$carteira_inadimplida_arrastada = factor(amostra$carteira_inadimplida_arrastada,
levels = c("nao","sim"),
ordered = T)
amostra = amostra|>
mutate(across(tcb:indexador, as.factor)) # Fator
# Editando variavel "numero_de_operacoes"
# Como "<= 15" é aproximadamente 74% da variável então compensa mais categorizar em intervalos
amostra$numero_de_operacoes = ifelse(amostra$numero_de_operacoes == "<= 15", "15", amostra$numero_de_operacoes)
amostra$numero_de_operacoes = as.numeric(amostra$numero_de_operacoes)
set.seed(123)
ind = sample(1:n,n*0.1)
amostra_treino = amostra[-ind,]
amostra_teste = amostra[ind,]
# /-------------Naive Bayes (e1071)-------------\
# Aplicando o modelo de Naive Bayes (Probabilidade Condicional)
modeloNB = e1071::naiveBayes(carteira_inadimplida_arrastada ~ .,data = amostra_treino)
predicao = predict(modeloNB, amostra_teste, type = "raw")
# Criando coluna de probabilidade e de inadimplencia
predicao = as.data.frame(predicao)
predicao$prob = ifelse(predicao$nao>predicao$sim, predicao$nao, predicao$sim)
predicao$inadimplente = ifelse(predicao$nao>predicao$sim, "nao", "sim")
predicao$inadimplente = as.factor(predicao$inadimplente)
# Proporção de erros e acertos
table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente)
prop.table(table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente))*100
# Matriz de Confusão
confuso = confusionMatrix(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente, positive = "nao")
confuso$overall[1]# acuracia 0.73
confuso$byClass[5]# precisao 0.99
confuso$byClass[1]# reconhecimento 0.71
1-((80+7178)/(16189+1274+80+7178))
# Vamos usar a função do pacote gmodels para comparar as classificações
# do modelo aos dados de treinamento com a classificação real
CrossTable(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c("Inadimplência real", "Inadimplência predita"))
str(amostra)
amostra$numero_de_operacoes = ifelse(amostra$numero_de_operacoes == "<= 15", "15", amostra$numero_de_operacoes)
amostra$numero_de_operacoes = as.numeric(amostra$numero_de_operacoes)
range(amostra$numero_de_operacoes)
nclass.Sturges(amostra$numero_de_operacoes)
table(cut(amostra$numero_de_operacoes, seq(0,4986451,20)))
amostra$numero_de_operacoes = cut(amostra$numero_de_operacoes, seq(0,4986451,20))
str(amostra$numero_de_operacoes)
n
rm(list = ls())
library(tidyverse)
library(e1071) # Pacote para aplicação do NAiveBayes (função NaiveBayes)
library(caret) # Pacote para aplicação do NaiveBayes (função train)
library(gmodels)
# Carregando arquivo finalizado
bacen = read.csv("~/R/PROJETOS R/1º Hackaton Decat/Dados BACEN 2025.csv")
names(bacen)
N = 247209
n = (0.6562099*(1-0.6562099))/
((1-(1/N)) *
((0.05/qnorm(1-0.05/2))^2) +
((0.6562099*(1-0.6562099))/N))
bacen = bacen|>
filter(uf == "BA")
n = (0.6562099*(1-0.6562099))/
((1-(1/N)) *
((0.01/qnorm(1-0.05/2))^2) +
((0.6562099*(1-0.6562099))/N))
bacen = bacen|>
filter(cliente == "PF")
# Utilizando AASs
N = 35858
n = (0.6562099*(1-0.6562099))/
((1-(1/N)) *
((0.01/qnorm(1-0.05/2))^2) +
((0.6562099*(1-0.6562099))/N))
set.seed(1234)
ind = sample(1:N,n)
amostra = bacen[ind,]
prop.table(table(amostra$carteira_inadimplida_arrastada))
bacen = read.csv("~/R/PROJETOS R/1º Hackaton Decat/Dados BACEN 2025.csv")
# vamo trabalhar apenas com a Bahia na região nordeste
prop.table(table(bacen$uf))*100 # no nordeste BA possui a maior proporção de casos
bacen = bacen|>
filter(uf == "BA")
# Utilizando AASs
N = 247209
n = (0.6562099*(1-0.6562099))/
((1-(1/N)) *
((0.01/qnorm(1-0.05/2))^2) +
((0.6562099*(1-0.6562099))/N))
# amostra 1
set.seed(1234)
ind = sample(1:N,n)
amostra = bacen[ind,]
amostra$data_base = NULL
amostra$uf = NULL
str(amostra)
amostra$Mes = factor(amostra$Mes, levels = c("jan","fev","mar","abr","mai","jun"),
ordered = T)
amostra$carteira_inadimplida_arrastada = factor(amostra$carteira_inadimplida_arrastada,
levels = c("nao","sim"),
ordered = T)
amostra = amostra|>
mutate(across(tcb:indexador, as.factor)) # Fator
# Editando variavel "numero_de_operacoes"
# Como "<= 15" é aproximadamente 74% da variável então compensa mais categorizar em intervalos
amostra$numero_de_operacoes = ifelse(amostra$numero_de_operacoes == "<= 15", "15", amostra$numero_de_operacoes)
amostra$numero_de_operacoes = as.numeric(amostra$numero_de_operacoes)
range(amostra$numero_de_operacoes)
nclass.Sturges(amostra$numero_de_operacoes)
table(cut(amostra$numero_de_operacoes, seq(0,4986451,20)))
amostra$numero_de_operacoes = cut(amostra$numero_de_operacoes, seq(0,4986451,20))
set.seed(123)
ind = sample(1:n,n*0.1)
amostra_treino = amostra[-ind,]
amostra_teste = amostra[ind,]
# /-------------Naive Bayes (e1071)-------------\
# Aplicando o modelo de Naive Bayes (Probabilidade Condicional)
modeloNB = e1071::naiveBayes(carteira_inadimplida_arrastada ~ .,data = amostra_treino)
predicao = predict(modeloNB, amostra_teste, type = "raw")
# Criando coluna de probabilidade e de inadimplencia
predicao = as.data.frame(predicao)
predicao$prob = ifelse(predicao$nao>predicao$sim, predicao$nao, predicao$sim)
predicao$inadimplente = ifelse(predicao$nao>predicao$sim, "nao", "sim")
predicao$inadimplente = as.factor(predicao$inadimplente)
# Proporção de erros e acertos
table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente)
prop.table(table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente))*100
# Matriz de Confusão
confuso = confusionMatrix(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente, positive = "nao")
confuso$overall[1]# acuracia 0.77
confuso$byClass[5]# precisao 0.79
confuso$byClass[1]# reconhecimento 0.85
# Vamos usar a função do pacote gmodels para comparar as classificações
# do modelo aos dados de treinamento com a classificação real
CrossTable(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c("Inadimplência real", "Inadimplência predita"))
# Outra maneira de aplicar NB
controle = trainControl(method = "repeatedcv", # Validação cruzada 5 reamostragens e 2 repetições
number = 5,
repeats = 2,
classProbs = T,
summaryFunction = twoClassSummary)
funil_param = expand.grid(usekernel = c(T,F),
fL = 0:1,
adjust = 1:5)
modeloNB = train(x = amostra_treino[,-20],y = amostra_treino[,20],'nb',trControl = controle,
tuneGrid = funil_param,
metric = "ROC")
modeloNB # Verificando melhores parâmetros que retornam melhor acuracia e kappa
predicao = predict(modeloNB, amostra_teste, type = "prob")
# Criando coluna de probabilidade e de inadimplencia
predicao$prob = ifelse(predicao$nao>predicao$sim, predicao$nao, predicao$sim)
predicao$inadimplente = ifelse(predicao$nao>predicao$sim, "nao", "sim")
predicao$inadimplente = as.factor(predicao$inadimplente)
# Matriz de Confusão
confuso = confusionMatrix(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente, positive = "nao")
confuso$overall[1]# acuracia 0.76
confuso$byClass[5]# precisao 0.79
confuso$byClass[1]# reconhecimento 0.85
# Vamos usar a função do pacote gmodels para comparar as classificações
# do modelo aos dados de treinamento com a classificação real
CrossTable(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE, mcnemar = T,
dnn = c("Inadimplência real", "Inadimplência predita"))
plot(varImp(modeloNB))
rm(list = ls())
bacen = read.csv("~/R/PROJETOS R/1º Hackaton Decat/Dados BACEN 2025.csv")
prop.table(table(bacen$uf))*100 # Trabalhando com todas os estados do nordeste
unique(bacen$uf)
# Utilizando AAEs
# 9 estratos
N = 1252617
Wh = c(97827/1252617,
247209/1252617,
164299/1252617,
134916/1252617,
122114/1252617,
182164/1252617,
96499/1252617,
121168/1252617,
86421/1252617)
Nh = c(97827,
247209,
164299,
134916,
122114,
182164,
96499,
121168,
86421)
q = qnorm(1-0.05/2)
PropH = as.data.frame(bacen|>
group_by(uf)|>
summarise("soma_nao" = sum(carteira_inadimplida_arrastada == "nao"),
"quantidade_uf" = table(uf),
"proporcao_nao" = soma_nao/quantidade_uf))$proporcao_nao
num = sum((Wh^2)*
(Nh/(Nh-1))*
((PropH*(1-PropH))/Wh))
den = ((0.01/q)^2)+
sum((Wh^2)*
((PropH*(1-PropH))/(Nh-1)))
n = num/den
# amostra 1
set.seed(1234)
ind = sample(1:N,n)
amostra = bacen[ind,]
amostra$data_base = NULL
amostra$uf = NULL
# Alterando tipo das variaveis
amostra$Mes = factor(amostra$Mes, levels = c("jan","fev","mar","abr","mai","jun"),
ordered = T)
amostra$carteira_inadimplida_arrastada = factor(amostra$carteira_inadimplida_arrastada,
levels = c("nao","sim"),
ordered = T)
amostra = amostra|>
mutate(across(tcb:indexador, as.factor)) # Fator
# Editando variavel "numero_de_operacoes"
# Como "<= 15" é aproximadamente 74% da variável então compensa mais categorizar em intervalos
amostra$numero_de_operacoes = ifelse(amostra$numero_de_operacoes == "<= 15", "15", amostra$numero_de_operacoes)
amostra$numero_de_operacoes = as.numeric(amostra$numero_de_operacoes)
range(amostra$numero_de_operacoes)
nclass.Sturges(amostra$numero_de_operacoes)
table(cut(amostra$numero_de_operacoes, seq(0,4986451,20)))
amostra$numero_de_operacoes = cut(amostra$numero_de_operacoes, seq(0,4986451,20))
set.seed(123)
ind = sample(1:n,n*0.1)
amostra_treino = amostra[-ind,]
amostra_teste = amostra[ind,]
# /-------------Naive Bayes (e1071)-------------\
# Aplicando o modelo de Naive Bayes (Probabilidade Condicional)
modeloNB = e1071::naiveBayes(carteira_inadimplida_arrastada ~ .,data = amostra_treino)
predicao = predict(modeloNB, amostra_teste, type = "raw")
# Criando coluna de probabilidade e de inadimplencia
predicao = as.data.frame(predicao)
predicao$prob = ifelse(predicao$nao>predicao$sim, predicao$nao, predicao$sim)
predicao$inadimplente = ifelse(predicao$nao>predicao$sim, "nao", "sim")
predicao$inadimplente = as.factor(predicao$inadimplente)
# Proporção de erros e acertos
table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente)
prop.table(table(amostra_teste$carteira_inadimplida_arrastada,predicao$inadimplente))*100
# Matriz de Confusão
confuso = confusionMatrix(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente, positive = "nao")
confuso$overall[1]# acuracia 0.73
confuso$byClass[5]# precisao 0.99
confuso$byClass[1]# reconhecimento 0.71
# Vamos usar a função do pacote gmodels para comparar as classificações
# do modelo aos dados de treinamento com a classificação real
CrossTable(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE,
dnn = c("Inadimplência real", "Inadimplência predita"))
# Outra maneira de aplicar NB
controle = trainControl(method = "repeatedcv", # Validação cruzada 5 reamostragens e 2 repetições
number = 5,
repeats = 2,
classProbs = T,
summaryFunction = twoClassSummary)
funil_param = expand.grid(usekernel = c(T,F),
fL = 0:1,
adjust = 1:5)
modeloNB = train(x = amostra_treino[,-20],y = amostra_treino[,20],'nb',trControl = controle,
tuneGrid = funil_param,
metric = "ROC")
modeloNB # Verificando melhores parâmetros que retornam melhor acuracia e kappa
predicao = predict(modeloNB, amostra_teste, type = "prob")
# Criando coluna de probabilidade e de inadimplencia
predicao$prob = ifelse(predicao$nao>predicao$sim, predicao$nao, predicao$sim)
predicao$inadimplente = ifelse(predicao$nao>predicao$sim, "nao", "sim")
predicao$inadimplente = as.factor(predicao$inadimplente)
# Matriz de Confusão
confuso = confusionMatrix(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente, positive = "nao")
confuso$overall[1]# acuracia 0.76
confuso$byClass[5]# precisao 0.81
confuso$byClass[1]# reconhecimento 0.83
# Vamos usar a função do pacote gmodels para comparar as classificações
# do modelo aos dados de treinamento com a classificação real
CrossTable(amostra_teste$carteira_inadimplida_arrastada, predicao$inadimplente,
prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE, mcnemar = T,
dnn = c("Inadimplência real", "Inadimplência predita"))
plot(varImp(modeloNB))
rm(list = ls())
help(gmodels)
??gmodels
install.packages("duckdb")
library(duckdb)
library(tidyverse)
library(data.table)
install.packages("duckdplyr")
library(duckdplyr)
install.packages("duckplyr")
library(duckplyr)
con = dbConnect(duckdb())
dbWriteTable(con, "C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv")
tbl(con, "C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv")
SELECT * FROM "C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv"
SELECT * FROM read.csv("C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv")
dbGetQuery(con, SELECT * FROM "C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv")
dbGetQuery(con, "SELECT * FROM 'C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv'")
View(dbGetQuery(con, "SELECT * FROM 'C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv'"))
dbGetQuery(con, "CREATE TABLE bacen AS
SELECT * FROM 'C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv'")
dbReadTable(con, bacen)
dbGetQuery(con, "CREATE TABLE bacen AS
SELECT * FROM 'C:/Users/fan79/Downloads/planilha_2025/planilha_202501.csv'")
dbReadTable(con, bacen)
dbListTables()
dbListTables(con)
# Armazena o caminho das planilhas
arquivos = list.files(path = "C:/Users/fan79/Downloads/plab", full.names = T)
# Lê cada arquivo e combina-os em um só
dbGetQuery("SELECT * FROM ([arquivos], union_by_name = true)")
# Lê cada arquivo e combina-os em um só
dbGetQuery(con, "SELECT * FROM ([arquivos], union_by_name = true)")
# Lê cada arquivo e combina-os em um só
dbGetQuery(con, "SELECT * FROM (arquivos, union_by_name = true)")
# Lê cada arquivo e combina-os em um só
dbGetQuery(con, "CREATE TABLE bacen AS SELECT * FROM ('C:/Users/fan79/Downloads/plab/planilha*.csv', union_by_name = true)")
dbListTables(con) # tabela bacen está aqui
# Lê cada arquivo e combina-os em um só
dbGetQuery(con, "CREATE TABLE bacen AS SELECT * FROM read.csv('C:/Users/fan79/Downloads/plab/planilha*.csv', union_by_name = true)")
# Lê cada arquivo e combina-os em um só
dbExecute(con, "CREATE TABLE bacen AS SELECT * FROM read.csv('C:/Users/fan79/Downloads/plab/planilha*.csv',union_by_name = true)")
# Lê cada arquivo e combina-os em um só
dbExecute(con, "CREATE TABLE bacen AS SELECT * FROM read_csv_auto('C:/Users/fan79/Downloads/plab/planilha*.csv',union_by_name = true)")
# Lê cada arquivo e combina-os em um só
dbGetQuery(con, "CREATE TABLE bacen AS SELECT * FROM read_csv_auto('C:/Users/fan79/Downloads/plab/planilha*.csv',union_by_name = true)")
dbDisconnect(con)
con = dbConnect(duckdb())
# Lê cada arquivo e combina-os em um só
dbGetQuery(con, "CREATE TABLE bacen AS SELECT * FROM read_csv_auto('C:/Users/fan79/Downloads/plab/planilha*.csv',union_by_name = true)")
dbGetQuery("SELECT * FROM bacen")
dbGetQuery(con, "SELECT * FROM bacen")
dbDisconnect(con)
# Transformar o arquivo em parquet para melhor performace
dbGetQuery(con, "COPY (SELECT * FROM read_csv_auto('C:/Users/lfgoliveira/Downloads/planilha/planilha*.csv')) TO 'C:/Users/lfgoliveira/Downloads/output.parquet' (FORMAT PARQUET)")
con = dbConnect(duckdb())
library(duckdb)
library(duckplyr)
library(tidyverse)
library(data.table)
con = dbConnect(duckdb())
# Transformar o arquivo em parquet para melhor performace
dbGetQuery(con, "COPY (SELECT * FROM read_csv_auto('C:/Users/lfgoliveira/Downloads/planilha/planilha*.csv')) TO 'C:/Users/lfgoliveira/Downloads/output.parquet' (FORMAT PARQUET)")
# Lê cada arquivo e combina-os em um só
dbGetQuery(con, "CREATE TABLE bacen AS SELECT * FROM read_parquet('C:/Users/lfgoliveira/Downloads/output.parquet',union_by_name = true)")
dbListTables(con) # tabela bacen está aqui
dbGetQuery(con, "DECLARE SELECT * FROM bacen")
dbGetQuery(con, "SELECT DECLARE * FROM bacen")
dbGetQuery(con, "SELECT DECLARE(*) FROM bacen")
View(dbGetQuery(con, "SELECT * FROM bacen LIMIT 10"))
str(dbGetQuery(con, "SELECT * FROM bacen LIMIT 10"))
dbGetQuery(con, "SELECT COUNT(*) FROM bacen LIMIT 10")
# Verificando variáveis
str(dbGetQuery(con, "SELECT * FROM bacen LIMIT 10"))
View(dbGetQuery(con, "SELECT * FROM bacen LIMIT 10"))
